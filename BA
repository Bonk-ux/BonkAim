-- // Services
local Workspace = cloneref(game:GetService("Workspace"))
local RunService = cloneref(game:GetService("RunService"))
local Camera = Workspace.CurrentCamera

-- // FOV Circle & Snapline
local fov_circle = Drawing.new("Circle")
fov_circle.Visible = true
fov_circle.Thickness = 1
fov_circle.Color = Color3.fromRGB(255, 255, 255)
fov_circle.Position = Camera.ViewportSize / 2
fov_circle.Radius = 120

local snap_line = Drawing.new("Line")
snap_line.Visible = false
snap_line.Color = Color3.fromRGB(255, 255, 255)
snap_line.Thickness = 1

-- // Silent Aim Settings
local Settings = {
    ["Combat"] = {
        ["Aimbot"] = {
            ["Enabled"] = true,
            ["Fov Size"] = 120,
            ["Resolver"] = false,
        }
    },
}

function to_viewport(pos)
    if typeof(pos) ~= "Vector3" then return Vector2.zero, false end
    local point, onScreen = Camera:WorldToViewportPoint(pos)
    return Vector2.new(point.X, point.Y), onScreen
end

-- // Projectile Data
local projectileinfo = {
    AR15 = {Speed = 1300, Drop = 3},
    Bow = {Speed = 300, Drop = 3},
    Crossbow = {Speed = 450, Drop = 3},
    M4A1 = {Speed = 1300, Drop = 4},
    SCAR = {Speed = 1300, Drop = 4},
    SVD = {Speed = 1400, Drop = 2},
    USP9 = {Speed = 600, Drop = 3},
    RPG = {Speed = 700, Drop = 3},
}

function Get_info(wep)
    local info = projectileinfo[wep]
    if not info then
        warn("Weapon info not found for:", wep)
        return 0, 0
    end
    return info.Speed, info.Drop
end

function CalculateBulletDrop(tPos, tVel, cPos, pSpeed, pDrop)
    local dTT = (tPos - cPos).Magnitude  
    local tTT = dTT / pSpeed  
    local pTP = tPos + (tVel * tTT * 6.5)  
    local dP = -pDrop ^ (tTT * pDrop) + 1  
    return pTP - Vector3.new(0, dP, 0), tTT
end

local target = nil
function GetClosestTarget(maxDistance)
    local closestTarget, closestDistance = nil, math.huge
    local viewportCenter = Camera.ViewportSize / 2

    for _, v in pairs(Players:GetPlayers()) do
        if v.Character and v.Character:FindFirstChild("Head") then
            local head = v.Character.Head
            local distanceToPlayer = (head.Position - Camera.CFrame.Position).Magnitude
            if distanceToPlayer <= maxDistance then
                local screenPoint, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - viewportCenter).Magnitude
                    if distanceFromCenter < closestDistance and distanceFromCenter < Settings["Combat"]["Aimbot"]["Fov Size"] then
                        closestTarget = v
                        closestDistance = distanceFromCenter
                    end
                end
            end
        end
    end
    return closestTarget
end

RunService.Heartbeat:Connect(function()
    target = GetClosestTarget(1200)
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local targetScreenPosition, onScreen = to_viewport(target.Character.Head.Position)
        if onScreen then
            snap_line.Visible = true
            snap_line.From = Camera.ViewportSize / 2
            snap_line.To = targetScreenPosition
        else
            snap_line.Visible = false
        end
    else
        snap_line.Visible = false
    end
end)

-- // Silent Aim Hook
local oldfromOrientation
oldfromOrientation = hookfunction(CFrame.fromOrientation, newcclosure(function(p, y, r)
    if debug.info(3, "f") and debug.info(3, "n") == "fire" then
        local wepdata = getstack(3, 1)
        if not wepdata or not target or not target.Character then
            return oldfromOrientation(p, y, r)
        end

        local origin = Camera.CFrame.Position
        local targetPosition = target.Character.Head.Position
        local velocityVector = target.Character.HumanoidRootPart.Velocity
        local speed, drop = Get_info(wepdata.type)

        if not targetPosition then
            return oldfromOrientation(p, y, r)
        end

        local predictedPosition, _ = CalculateBulletDrop(targetPosition, velocityVector, origin, speed, drop)

        return Camera.CFrame:Inverse() * CFrame.lookAt(origin, predictedPosition)
    end
    return oldfromOrientation(p, y, r)
end))
